#include <msp430.h>
#include "msprf24.h"
#include "nrf_userconfig.h"
#include "stdint.h"

    uint8_t addr_rx[5];
    int y;
    int p;
    char flag;
    char v_ID[60];  // will save vehicle ID for checking(for demonstration only), will store 20 vehicle ID, 3 char for each ID
    char i1,i2;
//    uint8_t addr_rx3[5];
    uint8_t addr_tx[5];
    uint8_t buf_r[14]; //rcvd msg 14 Bytes. See "Communication V2I I2X.docx" for details
    uint8_t buf_s[14]; //sent msg 14 Bytes. See "Communication V2I I2X.docx" for details
    char sender_add, road_no, rcvd_msg_flag;
    char msg1[41]="Vehicle ID 0x000000 left the intersection";
    char msg[223]="Intersection-0 Sender-RSU1    Road-1 TotalRoads-4 MsgType-0 Speed-50Kph Lane-2 Length-4m Class-2 Length-   Class-  Weight-      Warnings: Speeding-  Water-N Ice-N LowVisibility-Y EmergencyVechiel-N DamagedRoad-N ID-0x000000";
char random_ID_vchl;

volatile unsigned int user;
void radio_setup();
void activate_rx_mode();
void rcv_msg();
void send_msg();
void displaymsg(char lenght,char *message);
void displaysetup();
void createmsg0();
void createmsg1();
void createmsg2();
void createmsg3_sent();
void createmsg3_rcvd();
char hex2char(char h);  // if the hex digit is A,B,C,D,E,F, converting that to char

int main()
{
    WDTCTL = WDTHOLD | WDTPW;
    char temp;
    i1 = 0;
    i2 = 0;
    flag = 0;
    sender_add = 5; // 5 for all vehicles. 1,2,3,4 for 4 RSUs
    //road_no = 3;  // geting this info from RSU type 0 msg
    DCOCTL = CALDCO_16MHZ;
    BCSCTL1 = CALBC1_16MHZ;
    BCSCTL2 = DIVS_1;  // SMCLK = DCOCLK/2
    // SPI (USCI) uses SMCLK, prefer SMCLK < 10MHz (SPI speed limit for nRF24 = 10MHz)
//P1DIR |= 0x01;
//P1OUT |= 0x00;
    //user = 0xFE;

    P1IE |=  BIT3;                            // P1.3 interrupt enabled
      P1IES |= BIT3;                            // P1.3 Hi/lo edge
      P1REN |= BIT3;                            // Enable Pull Up on SW2 (P1.3)
      P1IFG &= ~BIT3;                           // P1.3 IFG cleared

    // seting timer to count from 0-255, this will be used for random ID sent from vehicle in type 1 msg
    CCR0 = 255;
    TACTL = TASSEL_2 + MC_1;                  // SMCLK, up mode

    displaysetup();
radio_setup();
activate_rx_mode();
rcvd_msg_flag = 0;  // no msg rcvd yet

_EINT();
//buf_s[0]=8;
//send_msg();

    while (1) {
        rcv_msg();

        if(flag == 1)
            {
            //for(p=0;p<30000;p++);
            send_msg();
            //for(p=0;p<30000;p++);
            activate_rx_mode(); // going back to rx mode after sending msg

            flag = 0;
            }

        if(rcvd_msg_flag == 1)   // new msg rcvd. see what action rqrd
        {
  // display msg. 1. type 0 rcvd, 2. type 1 sent 3. type 2 rcvd 4. type 3 sent 5. type 3 rcvd
        if(buf_r[2] == 0)  // if rcvd message type is 0
        {
            random_ID_vchl = TA0R;  // random ID generated by vehicle
            v_ID[i1] = random_ID_vchl;
            v_ID[i1+1] = buf_r[12];
            v_ID[i1+2] = buf_r[13];
            i1 = i1+3;

            buf_s[0] = sender_add;
            buf_s[1] = buf_r[1];
            buf_s[2] = 64;  // send back msg type 1
            buf_s[3] = buf_r[3];
            buf_s[4] = buf_r[4];
            buf_s[5] = buf_r[5];
            buf_s[6] = 0x58;    // length 5m, class 2
            buf_s[7] = 0x02;    // weight 2 tons
            buf_s[8] = 0;   // reserved
            buf_s[9] = buf_r[9];
            buf_s[10] = 0x40;   // warning: damaged road
            buf_s[11] = random_ID_vchl;  // random number generated by vehicle to complete the final ID for vehicle
            buf_s[12] = buf_r[12];
            buf_s[13] = buf_r[13];

            createmsg0();
            displaymsg(223, msg);   // display the rcvd msg, UART

            for(p=0;p<30000;p++);

            createmsg1();
            displaymsg(223, msg);   // display the msg to be sent, UART

            send_msg();
            activate_rx_mode(); // going back to rx mode after sending msg
        }
        if(buf_r[2] == 128)  // if rcvd message type is 2
                {
                        createmsg2();
                        displaymsg(223, msg);   // display type 2 msg rcvd, UART

                        buf_s[2] = 192;  // send back msg type 3

                        createmsg3_sent();
                        displaymsg(223, msg);   // display type 3 msg sent, UART

                    for(p=0;p<30000;p++);
                    send_msg();
                    activate_rx_mode(); // going back to rx mode after sending msg
                }
         if(buf_r[2] == 192)  // if rcvd message type is 3, not doing anything for demonstration
         {
             createmsg3_rcvd();
             displaymsg(223, msg);   // display type 3 msg rcvd, UART
             displaymsg(41, msg1);   // display type 3 msg rcvd, UART
         }
        }
        rcvd_msg_flag = 0;
    }
    return 0;
}

void rcv_msg(){
    if (rf_irq & RF24_IRQ_FLAGGED) {
        rf_irq &= ~RF24_IRQ_FLAGGED;
        msprf24_get_irq_reason();
    }
    if (rf_irq & RF24_IRQ_RX || msprf24_rx_pending()) {
        r_rx_payload(14, buf_r);
        msprf24_irq_clear(RF24_IRQ_RX);
//        P1OUT ^= 0x01;
        //user = 0xFE;
//        buf_r[2] = buf_r[2]*3.6; // converting m/s to Km/h
        rcvd_msg_flag = 1;  // rcvd new msg. see if any action required
    }
    else
        rcvd_msg_flag = 0;  // no new msg rcvd
}

void radio_setup(){
    /* Initial values for nRF24L01+ library config variables */
    rf_crc = RF24_EN_CRC | RF24_CRCO; // CRC enabled, 16-bit
    rf_addr_width      = 5;
    rf_speed_power     = RF24_SPEED_1MBPS | RF24_POWER_0DBM;
    rf_channel         = 120;

    msprf24_init();
    msprf24_set_pipe_packetsize(0, 14);
    msprf24_open_pipe(0, 0);  // Open pipe#0 with Enhanced ShockBurst
//    msprf24_open_pipe(1, 0);

    // Set our TX and RX address
    addr_rx[0] = 0x52; addr_rx[1] = 0x41; addr_rx[2] = 0x44; addr_rx[3] = 0x30; addr_rx[4] = 0x01;  // RAD01 ascii
//    addr_rx3[0] = 0x52; addr_rx3[1] = 0x41; addr_rx3[2] = 0x44; addr_rx3[3] = 0x30; addr_rx3[4] = 0x03;  // RAD03 ascii
    addr_tx[0] = 0x52; addr_tx[1] = 0x41; addr_tx[2] = 0x44; addr_tx[3] = 0x30; addr_tx[4] = 0x01;  //RAD05 ascii
//    w_tx_addr(addr_rx);
    w_rx_addr(0, addr_rx);  // pipe 0, reading rad01
//    w_rx_addr(1, addr_rx3);  //pipe 1, reading rad03
    w_tx_addr(addr_tx);
//    w_rx_addr(0, addr_tx);
}

void activate_rx_mode(){
    // Receive mode
     if (!(RF24_QUEUE_RXEMPTY & msprf24_queue_state())) {
         flush_rx();
     }
     msprf24_activate_rx();
     //LPM0;
}

void send_msg(){
    w_tx_payload(14, buf_s);
            msprf24_activate_tx();
            LPM0;

            if (rf_irq & RF24_IRQ_FLAGGED) {
                rf_irq &= ~RF24_IRQ_FLAGGED;

                msprf24_get_irq_reason();
                if (rf_irq & RF24_IRQ_TX){
                    //P1OUT &= ~BIT0; // Red LED off
                    //P4OUT |= BIT7;  // Green LED on
                }
                if (rf_irq & RF24_IRQ_TXFAILED){
                    //P4OUT &= ~BIT7; // Green LED off
                    //P1OUT |= BIT0;  // Red LED on
                }

                msprf24_irq_clear(rf_irq);
                user = msprf24_get_last_retransmits();
            }
            // for radio end
}

void displaysetup(){
    P1SEL = BIT1 + BIT2 ;                     // P1.1 = RXD, P1.2=TXD
              P1SEL2 = BIT1 + BIT2 ;                    // P1.1 = RXD, P1.2=TXD
              UCA0CTL1 |= UCSSEL_2;                     // SMCLK
              UCA0BR0 = 65;                            // 8MHz 9600
              UCA0BR1 = 3;                              // 8MHz 9600
              UCA0MCTL = UCBRS0;                        // Modulation UCBRSx = 1
              UCA0CTL1 &= ~UCSWRST;                     // **Initialize USCI state machine**
}

void displaymsg(char length,char *message)
{      for(y=0;y<length;y++){
    while (!(IFG2&UCA0TXIFG));                // USCI_A0 TX buffer ready?
      UCA0TXBUF = message[y];}
while (!(IFG2&UCA0TXIFG));
UCA0TXBUF = '\n';
while (!(IFG2&UCA0TXIFG));
UCA0TXBUF = '\n';
while (!(IFG2&UCA0TXIFG));
UCA0TXBUF = '\r';
}

void createmsg0(){

    // since sender_add is 5, it is a vehicle
    msg[22] = 'R';
    msg[23] = 'S';
    msg[24] = 'U';
    msg[25] = '1';
    msg[26] = ' ';
    msg[27] = ' ';
    msg[28] = ' ';
    msg[58] = '0';  // type 0 msg
    msg[66] = (buf_r[3]/10) + '0';  // speed, rcvd from RSU in msg type 0
    msg[67] = (buf_r[3]%10) + '0';  // speed, rcvd from RSU in msg type 0
    msg[104] = ' ';  // saved in vehicle
    msg[105] = ' ';
    msg[113] = ' '; // saved in vehicle
    msg[122] = ' '; // saved in vehicle
    msg[123] = ' ';
    msg[124] = ' ';
    msg[125] = ' ';
    msg[126] = ' ';
    if((buf_r[9] & 0x80) == 0x80)  // checking speeding warning bit in rcvd msg
        msg[147] = 'Y';
    else
        msg[147] ='N';
    msg[210] = 'N'; // detected by vehicle. buf_s[10]&64 = 64
    msg[217] = '0';
    msg[218] = '0';
    msg[219] = (buf_r[12]/16) + '0';
    msg[219] = hex2char(msg[219]); // if the hex digit is A,B,C,D,E,F, converting that to char
    msg[220] = (buf_r[12]%16) + '0';
    msg[220] = hex2char(msg[220]); // if the hex digit is A,B,C,D,E,F, converting that to char
    msg[221] = (buf_r[13]/16) + '0';
    msg[221] = hex2char(msg[221]); // if the hex digit is A,B,C,D,E,F, converting that to char
    msg[222] = (buf_r[13]%16) + '0';
    msg[222] = hex2char(msg[222]); // if the hex digit is A,B,C,D,E,F, converting that to char
}

void createmsg1(){

    // since sender_add is 5, it is a vehicle
    msg[22] = 'V';
    msg[23] = 'e';
    msg[24] = 'h';
    msg[25] = 'i';
    msg[26] = 'c';
    msg[27] = 'l';
    msg[28] = 'e';
    msg[58] = '1';  // type 1 msg, (buf_s[2] & 192) = 64
    msg[104] = '5';  // saved in vehicle
    msg[105] = 'm';
    msg[113] = '2'; // saved in vehicle
    msg[122] = '2'; // saved in vehicle
    msg[123] = 'T';
    msg[124] = 'o';
    msg[125] = 'n';
    msg[126] = 's';
    msg[210] = 'Y'; // detected by vehicle. buf_s[10]&64 = 64
    msg[217] = (random_ID_vchl/16) + '0';
    msg[217] = hex2char(msg[217]); // if the hex digit is A,B,C,D,E,F, converting that to char
    msg[218] = (random_ID_vchl%16) + '0';
    msg[218] = hex2char(msg[218]); // if the hex digit is A,B,C,D,E,F, converting that to char
//    msg[219] = '7';
//    msg[220] = '6';
//    msg[221] = '8';
//    msg[222] = '9';
}

void createmsg2(){
    createmsg1();
        msg[22] = 'R';
        msg[23] = 'S';
        msg[24] = 'U';
        msg[25] = '1';
        msg[26] = ' ';
        msg[27] = ' ';
        msg[28] = ' ';
        msg[58] = '2';  // type 2 msg, buf_r[2]&192=128
}

void createmsg3_sent(){
    createmsg1();
    msg[58] = '3';  // type 3 msg, buf_s[2]&192=192
}

void createmsg3_rcvd(){
    createmsg1();
    //buf_r[0]&15=3
        msg[22] = 'R';
        msg[23] = 'S';
        msg[24] = 'U';
        msg[25] = '3';
        msg[26] = ' ';
        msg[27] = ' ';
        msg[28] = ' ';
        msg[58] = '3';  // type 3 msg, buf_r[2]&192=192

        msg1[13]=(buf_r[11]/16) + '0';
        msg1[13]=hex2char(msg1[13]); // if the hex digit is A,B,C,D,E,F, converting that to char
        msg1[14]=(buf_r[11]%16) + '0';
        msg1[14]=hex2char(msg1[14]); // if the hex digit is A,B,C,D,E,F, converting that to char
        msg1[15]=(buf_r[12]/16) + '0';
        msg1[15]=hex2char(msg1[15]); // if the hex digit is A,B,C,D,E,F, converting that to char
        msg1[16]=(buf_r[12]%16) + '0';
        msg1[16]=hex2char(msg1[16]); // if the hex digit is A,B,C,D,E,F, converting that to char
        msg1[17]=(buf_r[13]/16) + '0';
        msg1[17]=hex2char(msg1[17]); // if the hex digit is A,B,C,D,E,F, converting that to char
        msg1[18]=(buf_r[13]%16) + '0';
        msg1[18]=hex2char(msg1[18]); // if the hex digit is A,B,C,D,E,F, converting that to char

        msg[217] = msg1[13];
        msg[218] = msg1[14];
        msg[219] = msg1[15];
        msg[220] = msg1[16];
        msg[221] = msg1[17];
        msg[222] = msg1[18];
}

char hex2char(char h)
{
    if(h == 58)
        h = 65;
    else if(h == 59)
        h = 66;
    else if(h == 60)
        h = 67;
    else if(h == 61)
        h = 68;
    else if(h == 62)
        h = 69;
    else if(h == 63)
        h = 70;

    return h;
}

// Port 1 interrupt service routine
#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
#pragma vector=PORT1_VECTOR
__interrupt void Port_1(void)
#elif defined(__GNUC__)
void __attribute__ ((interrupt(PORT1_VECTOR))) Port_1 (void)
#else
#error Compiler not supported!
#endif
{
  P1IFG &= ~BIT3;                           // P1.3 IFG cleared
  buf_s[2] = 192;  // send back msg type 3

  createmsg3_sent();
  msg[217] = (v_ID[i2]/16) + '0';
  msg[217] = hex2char(msg[217]); // if the hex digit is A,B,C,D,E,F, converting that to char
  msg[218] = (v_ID[i2]%16) + '0';
  msg[218] = hex2char(msg[218]); // if the hex digit is A,B,C,D,E,F, converting that to char
  msg[219] = (v_ID[i2+1]/16) + '0';
  msg[219] = hex2char(msg[219]); // if the hex digit is A,B,C,D,E,F, converting that to char
  msg[220] = (v_ID[i2+1]%16) + '0';
  msg[220] = hex2char(msg[220]); // if the hex digit is A,B,C,D,E,F, converting that to char
  msg[221] = (v_ID[i2+2]/16) + '0';
  msg[221] = hex2char(msg[221]); // if the hex digit is A,B,C,D,E,F, converting that to char
  msg[222] = (v_ID[i2+2]%16) + '0';
  msg[222] = hex2char(msg[222]); // if the hex digit is A,B,C,D,E,F, converting that to char
//  msg1[13]=msg[217];
//  msg1[14]=msg[218];
//  msg1[15]=msg[219];
//  msg1[16]=msg[220];
//  msg1[17]=msg[221];
//  msg1[18]=msg[222];
  displaymsg(223, msg);   // display type 3 msg sent, UART
  buf_s[11] = v_ID[i2];  // random number generated by vehicle to complete the final ID for vehicle
  buf_s[12] = v_ID[i2+1];
  buf_s[13] = v_ID[i2+2];
i2=i2+3;
flag = 1;
}

